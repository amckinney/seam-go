// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type SimulateCreateUnmanagedAccessCodeResponseAccessCode struct {
	Type      string
	Ongoing   *SimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing
	TimeBound *SimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound
}

func NewSimulateCreateUnmanagedAccessCodeResponseAccessCodeFromOngoing(value *SimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing) *SimulateCreateUnmanagedAccessCodeResponseAccessCode {
	return &SimulateCreateUnmanagedAccessCodeResponseAccessCode{Type: "ongoing", Ongoing: value}
}

func NewSimulateCreateUnmanagedAccessCodeResponseAccessCodeFromTimeBound(value *SimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound) *SimulateCreateUnmanagedAccessCodeResponseAccessCode {
	return &SimulateCreateUnmanagedAccessCodeResponseAccessCode{Type: "time_bound", TimeBound: value}
}

func (s *SimulateCreateUnmanagedAccessCodeResponseAccessCode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "ongoing":
		value := new(SimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Ongoing = value
	case "time_bound":
		value := new(SimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.TimeBound = value
	}
	return nil
}

func (s SimulateCreateUnmanagedAccessCodeResponseAccessCode) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "ongoing":
		var marshaler = struct {
			Type string `json:"type"`
			*SimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing
		}{
			Type: s.Type,
			SimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing: s.Ongoing,
		}
		return json.Marshal(marshaler)
	case "time_bound":
		var marshaler = struct {
			Type string `json:"type"`
			*SimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound
		}{
			Type: s.Type,
			SimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound: s.TimeBound,
		}
		return json.Marshal(marshaler)
	}
}

type SimulateCreateUnmanagedAccessCodeResponseAccessCodeVisitor interface {
	VisitOngoing(*SimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing) error
	VisitTimeBound(*SimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound) error
}

func (s *SimulateCreateUnmanagedAccessCodeResponseAccessCode) Accept(v SimulateCreateUnmanagedAccessCodeResponseAccessCodeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "ongoing":
		return v.VisitOngoing(s.Ongoing)
	case "time_bound":
		return v.VisitTimeBound(s.TimeBound)
	}
}
