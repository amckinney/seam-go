// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCode struct {
	Type      string
	Ongoing   *AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing
	TimeBound *AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound
}

func NewAccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeFromOngoing(value *AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing) *AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCode {
	return &AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCode{Type: "ongoing", Ongoing: value}
}

func NewAccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeFromTimeBound(value *AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound) *AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCode {
	return &AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCode{Type: "time_bound", TimeBound: value}
}

func (a *AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "ongoing":
		value := new(AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Ongoing = value
	case "time_bound":
		value := new(AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.TimeBound = value
	}
	return nil
}

func (a AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCode) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "ongoing":
		var marshaler = struct {
			Type string `json:"type"`
			*AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing
		}{
			Type: a.Type,
			AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing: a.Ongoing,
		}
		return json.Marshal(marshaler)
	case "time_bound":
		var marshaler = struct {
			Type string `json:"type"`
			*AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound
		}{
			Type: a.Type,
			AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound: a.TimeBound,
		}
		return json.Marshal(marshaler)
	}
}

type AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeVisitor interface {
	VisitOngoing(*AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeOngoing) error
	VisitTimeBound(*AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeTimeBound) error
}

func (a *AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCode) Accept(v AccessCodesSimulateCreateUnmanagedAccessCodeResponseAccessCodeVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "ongoing":
		return v.VisitOngoing(a.Ongoing)
	case "time_bound":
		return v.VisitTimeBound(a.TimeBound)
	}
}
